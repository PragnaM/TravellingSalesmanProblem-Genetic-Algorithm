# -*- coding: utf-8 -*-
"""
Created on Wed Sep 29 16:08:27 2021

@author: Pragna M
"""

import numpy as np
import random
import matplotlib.pyplot as plt

#Calculate fitness
def fitnessFunction(population):
    fitness=[0]*populationInstances
    for i in range(0,populationInstances):
        for j in range (0,numberOfCities-1):
            city1,city2= population[i][j],population[i][j+1]
            fitness[i] = fitness[i] + distancematrix[city1,city2] #sum of distances from city1 to cityN
        
        lastcity=population[i][-1]
        firstcity= population[0][0]
        fitness[i]= fitness[i]+ distancematrix[lastcity,firstcity] #Distance from cityN back to city1

    for i in range(0, len(fitness)): #used to plot graph
        fitness[i]=1/fitness[i]
    return fitness

def poolOfParents(population, fitness):
    poolOfParents={}
    populationTuple=tuple(population)
    for i in range(0,populationInstances):
        populationTuple=tuple(population[i])
        poolOfParents[populationTuple]=fitness[i]

    #sorted Pool of Parents
    poolOfParentssorted = sorted(poolOfParents.items(), key=lambda x: x[1])
  
    population.clear() # append the best instances to the population based on elitism rate
    for i in range(0,int((elitismPercentage/100)*populationInstances)):
        population.append(poolOfParentssorted[i][0])

    return poolOfParentssorted

def generateChild(poolOfParentsSorted):
    #select the best 50% in the sorted pool of parents for offspring generation
    selectionQuantity = int(populationInstances/2) 

    for i in range(0,selectionQuantity):
        child1=[]
        child2=[]
        parents=[]
        parents=random.sample(poolOfParentsSorted, 2)
        parent1= parents[0][0]
        parent2= parents[1][0]

        #ordered crossover
        randomindex1=random.randint(0,numberOfCities-1)
        randomindex2=random.randint(0,numberOfCities-1)
        
        if (randomindex1==randomindex2):  # check if random indexes are equal
            randomindex2=randomindex2-1
            
        if (randomindex1 > randomindex2): #ensure that the higher value is in randomindex2 
            a=randomindex2
            randomindex2=randomindex1
            randomindex1=a      
        
        
        child1=[-1]*numberOfCities #initialise all elements of child1 and child2 to -1
        child2=[-1]*numberOfCities
       
        for j in range(0, populationInstances): #perform ordered crossover 
            for k in range(randomindex1, randomindex2+1):
                child1[k]=parent1[k]
                child2[k]=parent2[k]

        for city in parent2:
           if not(child1.__contains__(city)):
               for j in range(0,numberOfCities):
                   if child1[j]==-1:
                       child1[j]=city
                       break;
        for city in parent1:
            if not(child2.__contains__(city)):
               for j in range(0,numberOfCities):
                   if child2[j]==-1:
                       child2[j]=city
                       break;
                       
        #Check mutation rate and perform mutation if necessary
        if (random.random() < mutationPercentage):
                child1,child2=mutationFunction(child1,child2)
        newPopulation=nextGenAdd(child1,child2)  
    
    return newPopulation

def mutationFunction(child1,child2):
    mutateindex1=random.randint(0,numberOfCities-1)
    mutateindex2=random.randint(0,numberOfCities-1)
    
    if (mutateindex1==mutateindex2):
        mutateindex2=mutateindex2 - 1
     
    if (mutateindex1 > mutateindex2):
            swap=mutateindex2
            mutateindex2=mutateindex1
            mutateindex2=swap     
        
     #Swap mutation   
    mutate1=child1[mutateindex1]
    child1[mutateindex1]=child1[mutateindex2]
    child1[mutateindex2]=mutate1
    
    mutate2=child2[mutateindex1]
    child2[mutateindex1]=child2[mutateindex2]
    child2[mutateindex2]=mutate2
    
    return child1,child2 

def generations(population):
    # repeat the entire process for number of generations entered by the user
    fitness=fitnessFunction(population)
    poolOfParentsSorted= poolOfParents(population,fitness)
   # population.clear()
    newPopulation=generateChild(poolOfParentsSorted)
    fitnessNewPopulation=[]
    fitnessNewPopulation=fitnessFunction(newPopulation)
   
    return newPopulation, fitnessNewPopulation


def nextGenAdd(child1,child2):
    # add the offsprings generated by each pair of parents to the next generation
    newPopulation.append(child1)
    newPopulation.append(child2)
   
    return newPopulation

#Generate dataset in matrix format
numberOfCities = int(input("Enter number of Cities:"))  # size of matrix
distancematrixhalf = np.random.randint(0,100,size=(numberOfCities,numberOfCities)) # random symmetric matrix
distancematrix = (distancematrixhalf + distancematrixhalf.T)
for i in range (0,numberOfCities):
    distancematrix[i][i]=0 # diagonal elements=0
print (distancematrix)

#Get the initial population
populationInstances= int(input("Enter number of instances of Population:"))

initialpopulation= []
for i in range(0,populationInstances):
        p=random.sample(range(0,numberOfCities ), numberOfCities)    
        initialpopulation.append(p)
      
fitness=[]


#Get fitness of initial population
fitness= fitnessFunction(initialpopulation)
newPopulation= []

#Get the Elitism rate
elitismPercentage=int(input("Enter Elitism Percentage:" ))

#Get a dictionary of parent:fitness
poolOfParentsSorted= poolOfParents(initialpopulation, fitness)

#Get the Mutation rate
mutationPercentage=float(input("Enter Mutation Percentage: "))


fitnessNewPopulation=[]
# Create offsprings and add to population
newPopulation=generateChild(poolOfParentsSorted)


#Insert offsprings into population
numberOfGenerations=int(input("Enter number of Generations:"))
xaxis=[]
yaxis=[]

#plot the graph showing min(Distance) vs numberOfGenerations
for i in range(0,numberOfGenerations+1):
    newPopulation,fitnessNewPopulation=generations(newPopulation)
    xaxis.append(i)
    print("Generation:", i)
    yaxis.append(min(fitnessNewPopulation))
    print("Minimum Distance in this Generation:",min(fitnessNewPopulation))

plt.plot(xaxis,yaxis)
plt.xlabel("Generation")
plt.ylabel("Distance")
plt.show()
               
  








    
    
        
        

